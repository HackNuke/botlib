#!/usr/bin/env python3
# This file is placed in the Public Domain.

"""

% BOT(1) BOT version 130
% Bart Thate <bthate67@gmail.com>
% Aug 2021

# NAME
BOT - pure python3 irc bot

# SYNOPSIS

| bot \<cmd>\ [options] [key=value] [key==value]

# DESCRIPTION

BOT an attempt to achieve OS level integration of bot technology directly
into the operating system. A solid, non hackable bot version, that can offer
"display in your irc channel" functionality to the unix programmer. BOTLIB
runs on both BSD and Linux, is placed in the Public Domain, and, one day,
will be the thing you cannot do without ;]

# OPTIONS

| -b	\# bork mode
| -c	\# start client
| -d	\# start daemon
| -v	\# use verbose
 
# CONFIGURATION

| bot cfg server=localhost channel=\#bot nick=bot
| bot m=irc,rss

| bot pwd \<nick\> \<password\>
| bot cfg password=\<outputofpwd\>

| bot cfg users=true 
| bot met \<userhost\>

| bot rss \<url\>

# COPYRIGHT

**BOT** is placed in the Public Domain, no COPYRIGHT, no LICENSE.

"""

import os
import sys
import termios
import time

wd = os.path.expanduser("~/.bot")

from bot.obj import keys, spl
from bot.run import Client, Runtime
from bot.tbl import Table
from bot.trc import get_exception


class Kernel(Runtime):

    def error(self, txt):
        print(txt)
        sys.stdout.flush()
        
    def log(self, txt):
        if "PING" in txt or "PONG" in txt:
            return
        print(txt)
        sys.stdout.flush()


class CLI(Client):

    def handle(self, clt, e):
        k.put(e)

    def raw(self, txt):
        print(txt)
        sys.stdout.flush()

class Console(Client):

    def handle(self, clt, e):
        k.put(e)
        e.wait()

    def poll(self):
        return input("> ")

    def raw(self, txt):
        print(txt)
        sys.stdout.flush()


clt = Console()
k = Kernel()
t = Table()


import bot.all


def daemon():
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    os.umask(0)
    si = open("/dev/null", "r")
    so = open("/dev/null", "a+")
    se = open("/dev/null", "a+")
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())


def wrap(func):
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        func()
    except KeyboardInterrupt:
        pass
    except PermissionError as ex:
        print(str(ex))
    except Exception as ex:
        print(get_exception())
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)

def initialize(mods):
    m = ""
    for mn in spl(mods):
        m += ",bot.%s" % mn
    k.init(m)

def main(): 
    k.boot()
    wait = False
    t.scan("bot")
    if k.cfg.txt:
        return k.cmd(k.cfg.txt)
    if k.cfg.verbose:
        k.log("BOT started at %s" % time.ctime(time.time()))
        k.log(k.cfg)
        k.log(",".join(sorted(keys(t.modnames))))
    if k.opt("d"):
        daemon()
        k.cfg.m += ",irc"
    if k.opt("dc"):
        k.start()
        initialize(k.cfg.m)
        wait = True
    if k.opt("c") or k.cfg.m:
        clt.start()
        wait = True
    if k.opt("b"):
        k.cfg.bork = True
    if k.opt("w") or wait:
        k.wait()


wrap(main)
